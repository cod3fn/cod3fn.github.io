<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
    
     <entry>
        <title>使用hugo Github Travis打造个人博客</title>
        <url>https://xiongdahu.github.io/post/%E4%BD%BF%E7%94%A8hugo-github-travis%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>code</tag>
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>wsl-docker-environment</title>
        <url>https://xiongdahu.github.io/post/wsl-docker-environment/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>wsl</tag><tag>code</tag>
        </tags>
        <content type="html"> 使用wsl,MobaXterm,cmder,docker打造可视化的linux开发环境
离不开Windows的理由很多,作为后端开发需要使用linux的情况也很多,双系统总归是不方便,而且linux下的GUI体验也没用Win 10好. 如果使用虚拟机,那么文件交换和网络等各种问题也需要解决,对系统的内存要求也更高一些.微软为了让更多的开发人员留在Win10上面,开发了wsl功能.目前的实际体验已经很棒,今天介绍一下如何打造一个可视化的linux开发环境&amp;ndash;即在Win10启动linux的GUI软件,例如vscode等.在wsl启动vscode写代码可以有效避免一些Windows和linux的编码和换行问题.
本教程分为2部分:
配置wsl可视化
 在wsl使用docker
   以下内容中 wsl和ubuntu含义相同,console和命令行含义相同.
 配置wsl可视化 系统要求是Win 10 1803&#43;版本(低于1803的wsl功能有问题),必须是专业版或教育版才有wsl功能.以下内容的命令行如果开头有&amp;gt;字符请忽略.
windows开启wsl功能 控制面板\程序\程序和功能\开发或关闭Windows功能 &amp;gt; 勾选 &amp;lsquo;适用于linux的Windows子系统&amp;rsquo;和 &amp;lsquo;hyper-V&amp;rsquo;(docker for Windows需要这个功能,也可以使用virtualbox代替), 重启电脑.
windows下载wsl Windows store搜索&amp;raquo;wsl&amp;raquo;或者&amp;raquo;ubuntu&amp;raquo;下载ubuntu版本. ubuntu和ubuntu1804是一个版本,ubuntu1604是旧的版本.安装完成你的Windows应用列表会有一个ubuntu应用,点击图标即可打开ubuntu命令行.第一次启动需要等待初始化,然后设置用户名和密码.由于字体难看,所以不用这个自带的命令行而使用下面的cmder.
windws下载cmder软件 cmder是Windows下最强的命令行功能. 不要下载mini那个,里面没用vim和git.第一次启动cmder记得修改cmder启动目录.修改路径如图所示.
wsl修改软件源,使用阿里云的源. &amp;gt; sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak &amp;gt; sudo sed -i &amp;#39;s/archive.ubuntu.com/mirrors.aliyun.com/g&amp;#39; /etc/apt/sources.list &amp;gt; sudo apt update &amp;gt; sudo apt upgrade -y wsl安装必要软件 # 安装你需要的软件,git和vim是必须的,后面的编辑命令是使用vim &amp;gt;sudo apt install openjdk-8-jdk-headless openjdk-8-jre-headless maven git unzip vim -y 修改wsl下Windows磁盘挂载点 默认的Windows磁盘在wsl的访问方式是/mnt/d/开头,d表示d盘.但是docker on linux的访问路径是 /d,所以这里需要修改挂载点路径.
sudo vim /etc/wsl.conf ##添加3行内容 [automount] root = / options = &amp;#34;metadata&amp;#34; 退出wsl重启,发现/mnt已经没了,当前目录应该是/c/xxx或者/d/xxx.
wsl设置SSH功能 这样可以借助MobaXterm的X11转发功能打开GUI软件
&amp;gt;sudo vim /etc/ssh/sshd_config #取消Port的注释,并将端口改为2222 (端口需要大于1000) #将PasswordAuthentication的值改为yes. #重启 ssh server: sudo service ssh --full-restart #将ssh server设置为服务: sudo service ssh start wsl安装vscode和中文字体 因为wsl没用中文字体将显示豆腐块.
# install chinese fonts for wsl,font name: &amp;#39;Noto Sans Mono CJK SC&amp;#39; sudo apt install -y fonts-noto-cjk fonts-noto-cjk-extra # Win10下载vscode的deb包,cd到该目录,使用下面命令安装 sudo apt install ./code_1.31.1-1549938243_amd64.deb # 在wsl要启动code必要依赖 sudo apt install libgtk2.0-0 libxss1 libasound2 windows安装VcXsrv 用它的X11转发功能.安装后默认选项即可,可以设置为开机启动.
启动wsl的vs code 在wsl输入code .,等待2秒,你会发现Windows任务栏启动了一个vscode,如果没用启动成功,说明你的MobaXterm的X11转发功能有问题.
配置vscode. 上面打开的vscode有2个问题:中文显示豆腐块,和不能全屏. 打开vscode的设置
#在字体里面先设置你想要英文字体,逗号跟上&amp;#39;Noto Sans Mono CJK SC&amp;#39; #搜索titleBarStyle,将&amp;#39;Window: title Bar Style&amp;#39;设置为 native #上面2个设置也可通过直接编辑文件设置,例如我的vscode文件设置是 &amp;gt; cat ~/.config/Code/User/settings.json { &amp;#34;Window.titleBarStyle&amp;#34;: &amp;#34;native&amp;#34;, &amp;#34;editor.fontFamily&amp;#34;: &amp;#34;monospace,&amp;#39;Noto Sans Mono CJK SC&amp;#39;&amp;#34; } 至此,已经可以在linux下面开发了.当然,其他GUI软件没用测试不确定是不是会有小问题.但是vscode已经可以应付很多开发工作了.
在wsl使用docker 目前的wsl是不支持运行docker的,但是可以在wsl使用Windows的docker,在使用上面是无感的.
 安装docker for Windows. 这个就不细说了,注意docker社区版也是需要注册才能下载的.
 启动docker for Windows,右键任务栏的docker图标,&amp;laquo;settings&amp;raquo;,勾上 &amp;laquo;expose the daemon on tcp:/localhost:2375 without TLS&amp;raquo;,这样在wsl可以访问这个docker服务.
 wsl安装docker,详细内容可以参考官方文档,下面仅列出必要bash命令.
#安装必要组件 sudo apt install -y apt-transport-https ca-certificates curl software-properties-common #gpg签名 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 #添加docker安装源 sudo add-apt-repository &amp;#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs)\ stable&amp;#34; sudo apt update sudo apt install -y docker-ce #通过pip安装docker-compose sudo apt install -y python python-pip sudo usermod -aG docker $USER pip install --user docker-compose #验证docker安装是否成功 docker info docker-compose --version #修改docker服务为Windows的docker echo &amp;#34;export DOCKER_HOST=tcp://localhost:2375&amp;#34; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; source ~/.bashrc #验证是否可以访问Windows的docker服务,看image list命令输出和Windows的命令行下面的image list输出是不是完全一样. 可以先在Windows下用docker拉几个镜像.然后在wsl验证 docker image list  至此,wsl的docker服务也配置完成.
</content>
    </entry>
    
     <entry>
        <title>neo4j intro</title>
        <url>https://xiongdahu.github.io/post/neo4j-intro/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>neo4j</tag><tag>code</tag><tag>database</tag>
        </tags>
        <content type="html">  neo4j图数据库介绍 neo4j是目前排名最高的图数据库,分为商业和社区版本,社区版只支持单机,而且查询的运行时(runtime)不同(cypher runtime:interpreted(社区版),slotted(企业版)). 数据库排名可以在 https://db-engines.com/en/ranking/graph&#43;dbms 查看,下一代最有前景的开源图数据库是dgraph,目前还积极开发中,生产未就绪,等他的Java客户端再成熟一点可以试用.
neo4j数据库中只有3个概念: Node, Relationship, Properties. Node表示实体类别,使用Label区分,例如一个节点可以有Person/Father等多个标签,Relationship即关系,雇佣关系,父子关系,投资关系,交易关系等. Node和Relationship都可以有Proerties,属性自身不分是属于节点还是属于关系,例如Person可以有属性name,关系也可以用属性name.你可以在neo4j browser左侧看到当前数据库的所有Node Label,Relationship Type,Properties.
本地安装和在线沙箱 neo4j背后的公司为了吸引用户,提供了一些好玩的数据库沙箱,这些沙箱数据库已经提前放了一些主题数据,例如购物数据,国会关系数据.你可以通过注册登录 https://neo4j.com/sandbox-v2/, 选择一个数据沙箱实例进行学习试玩.当然你也可以下载社区版,命令行 neo4j.bat console启动,打开127.0.0.1:7474开始学习.
一个neo4j支持多个数据库但是一次只能激活一个数据库,一个数据库所有文件都在$neo4j_home\data\databases目录的独立文件夹,在conf/neo4j.conf的dbms.active_database=graph.db指定激活那个数据库.
cypher查询语言 neo4j使用cypher语言作为查询语言.这是一种模式匹配的声明式语言.基本语法和SQL相似.
cypher中常用的子句(clause)有: MATCH,RETURN,WITH,WHERE,UNWIND,LIMIT,UNION,SKIP,SET. RETURN,LIMIT WHERE和SQL中是一样的,UNWIND这些需要用到再查看文档,这里介绍MATCH和WITH.
MTACH用于指定搜索的模式.例如希望找到&amp;rsquo;Tom Hanks&amp;rsquo;在2018演过的所有电影:MATCH (p:ACTOR {name:&#39;Tom Hanks&#39; }) -[r: ACT_IN]-&amp;gt;(m:MOVIE {time: &#39;2018&#39;}),这是一个模式,可以直接REUREN返回p,r,m等变量.可以看到模式中的节点(Node Label)使用();关系类型(Relationship Type)使用[]指定,如果不关心type,那么[]可以省略.使用&amp;ndash;; 属性(Properties) 使用{pname: pvalue}指定.
WITH的作用和python的with非常相似(实际上cypher语言借鉴了python的list处理语法),用于修改一些变量,变量一般都是上一个子句的查询结果,修改之后传给下一个子句.例如下面的语句找到和Anders有关系的人的年龄最大的那个人,返回那个人的所有认识的人的名字.
MATCH (n { name: &amp;#39;Anders&amp;#39; })--(m) WITH m ORDER BY m.age DESC LIMIT 1 MATCH (m)--(o) RETURN o.name cypher手册: https://neo4j.com/docs/cypher-manual/3.5/clauses/
cypher的操作符 如果需要进行cypher调优,有必要了解一下cypher的操作符. 一般编程语言的代码在被执行前都会被编译得到抽象语法树(AST). 例如Java代码,一个Java文件会被抽象为一个package,class, method,variable declare等不同部分得到一个Class对象. cypher语句一样会被编译得到一棵语法树(AST),每个树节点是一个操作符. 从叶节点的操作符开始执行,得到的结果依次返回给父节点进一步处理.常见的操作符有:AllNodesScan(全局扫描,只能作为叶节点),NodeByLabelScan,Apply等.例如MATCH (n) return n会得到一个AllNodesScan和ProduceResults操作符构成的AST, 你可以通过PROFILE查看你语句编译后得到的操作符构成的执行计划.
# 执行语句得到下面的表格 PROFILE MATCH (p:Person { name: &amp;#39;Tom Hanks&amp;#39; }) RETURN p # 省略了部分列 &#43;-----------------&#43;----------------&#43;------&#43;---------&#43;-----------------&#43; | Operator | Estimated Rows | Rows | DB Hits | Page Cache Hits | &#43;-----------------&#43;----------------&#43;------&#43;---------&#43;-----------------&#43; | &#43;ProduceResults | 1 | 1 | 0 | 0 | | | &#43;----------------&#43;------&#43;---------&#43;-----------------&#43; | &#43;NodeIndexSeek | 1 | 1 | 2 | 0 | &#43;-----------------&#43;----------------&#43;------&#43;---------&#43;-----------------&#43; cypher runtime pass
neo4j browser介绍 和大多数数据库一样,neo4j是server-client的数据库,支持http和bolt2中协议.neo4j自带一个基于浏览器的客户端,只需在浏览器输入serverIp:7474即可使用.
neo4j browser自带一个教程和电影关系的数据库初始化脚本.方便你可以学习.下面介绍几个常用的命令.
 :help  help命令显示各种帮助提示. 常见的topic有 :help cypher :help commands :help keys :help param
 :play 交互式学习命令. 例如,:play movie graph 进入基于电影数据库的教程.
 :param 命令,设置变量. :param usrname =&amp;gt; &amp;laquo;xiongdahu&amp;raquo;,注意,变量名和=&amp;gt;之间有空格.设置变量之后可以使用变量MATCH (n:Person) WHERE n.name = $usrname
 :params 显示当前已经设置的所有变量. 也可以使用:params {name: &amp;lsquo;Stella&amp;rsquo;, age: 24} 覆盖目前的变量. 但是这个命令没用类型安全.
  spring-neo4j配置 pass
cypher调优 cypher是一种声明式的,模式匹配的查询语言.模式在cypher语言中非常重要.如何合理地设计查询中的模式是cypher性能可调优空间最大的地方.下面给出常见的优化建议.
需要说明的是,后面的这些建议其实大都可以在cypher手册找到,如果感兴趣,建议通读这份长文档&amp;hellip;
避免全局scan cypher 是一种模式匹配的语言,默认会进行全局扫描,除非你告诉它不要.所以起始节点的label非常重要.起始的模式匹配基数大小也非常重要.
缓存和硬盘IO neo4j数据库将数据文件和Page Cache作了映射,如果在缓存中没有查询到,neo4j会从硬盘加载数据文件.第二次查询就可以走缓存.所以需要充分利用Page Cache.记住第一次查询总是会比较慢,因为没用缓存.neo4j 有2级缓存:string cache和AST cache
 string cache
默认neo4j在cache中保留1000个查询计划,可在conf/neo4j.conf中参数dbms.query_cache_size修改这个设置.
  需要注意的是cache是根据语句的string hash值判断的,所以一样的语句仅仅是大小写不一样或者空白符不一样对缓存来说也是2个语句.
PROFILE/EXPLAIN语句只会cache其去掉PROFILE/EXPLAIN之后的部分.例如:MATCH (n) return COUNT(n);和PROFILE MATCH (n) return COUNT(n);的cache是一致的.
 AST cache
编程语言都有语法树.如果在string cache中没有找到缓存.那么会将查询正规化,得到语法树并将其缓存.正规化的同时也会做一些优化,例如
match (n:Person {id:101}) return n;在正规化之后得到match (n:Person) where n.id={param1} return n; {param1: 101},AST cache不区分大小写,空格等,所以以下查询是一致的:
  match (n:Person) where n.id=101 return n; match (n:Person {id:101}) return n; MATCH ( n:Person { id : 101 } ) RETURN n; execution plan 当cypher引擎收到查询语句后如果没用找到对应的缓存,那么Cypher query planner会将语句规范化,优化后编译得到一个执行计划(execution plan).这个执行计划会缓存一切且可以复用. 当查询缓存过多,或者数据库的数据变化大时(设置参数是)这个执行计划则失效被移除.在查询中使用参数而不是字面量值,可以提高一个执行计划的复用率.
更多信息参考文档:https://neo4j.com/docs/cypher-manual/3.5/execution-plans/#execution-plan-introduction
查看查询计划 如果想要查看查询语句的执行计划,可以在查询语句前加上 EXPLANIN OR PROFILE 关键字, 你可以在neo4j browser查看query plan找到性能瓶颈.结果左侧边里面第3个tab会给出详细的性能警告(warn).
EXPLAIN只会给出语句的分析结果;而PROFILE则会执行你的查询语句把给出耗时最多的报告,以及每个操作符返回了多少行记录. 注意,profiling会消耗很多资源,所以不要在生产环境中频繁使用.调优的基础是基于cypher的操作符,所以需要你对操作符有基本的了解.
索引 数据库离不开索引.这里有个小陷阱,最早谱系的节点是企业客户(label: COR_CUSTOMER)&#43;和几十个零售客户节点(label:RTL_CUSTOMER),我在查询语句起始节点没有指定label,没用遇到性能问题,后来加入了3百万的个人节点数据后,原来1s的查询变成了1分半钟. 所以在干扰的label比较少时,你不会察觉到性能问题.务必在起始节点指定label,即使目前只有一个label,最好也提前加上.
然而,cypher语句目前不允许在一个节点指定多个label,例如你希望起点label是COR_CUSTOMER|RTL_CUSTOMER,这个是不允许的. 只能在where语句指定.
MATCH n WHERE n:COR_CUSTOMER OR n:RTL_CUSTOMER RETURN n 在3.0之前的neo4j中使用上面的语句,会导致一个AllNodesScan,在3.0之后,该语句则是将2个NodeByLabelScan匹配结果UNION然后DISTINCT的结果. 所以是搜索2次再合并结果.你可以在上面的cypher语句前面添加EXPLAIN查看执行计划,已确定你的语句是否会导致全局扫描.
SO上关于多个label匹配的讨论
大结果集 如果你的查询返回结果集太大,例如几M大小,那么你可能需要考虑你的设计了. 过大的结果集会导致查询返回变慢,要注意,这些结果会占用你的缓存空间,而如果在网络情况不好时,情况家更加糟糕了.
目前谱系对这一块并没有优化,最大的谱系的返回接口可能达到1M多,加上ES的数据,前端接收数据会有4M多.
锁 当你修改节点的信息时,节点会被锁定;如果修改关系,关系会被锁定;如果增加/删除关系,那么2个节点和这个关系都会被锁定.而如果此时有节点/关系的相关查询请求,这些请求会等待.所以,如果你需要将50个节点加入一个组(group)&amp;ndash;即添加50个关系,如果你调用50次方法,那么这个group节点被lock的时间较长,此时可以通过UNWIND和列表(list)参数处理这个问题.
MATCH (g:Group { uuid: $groupUuid }) UNWIND $personUuidList as personUuid MATCH (p:Person { uuid : personUuid }) MERGE (p)-[:IS_MEMBER]-&amp;gt;(g)  常见查询错误  变量名
 label忘记添加冒号,例如MATCH (Person) 和 MATCH (:Person) 是完全不一样的,前者Person是变量,不走索引.
 有过大的中间结果集,优化你的语句时思考:尽早distinct,尽早limit,使用collect减少结果的行数,在正确地方使用order by;
  多个UNWIND语句导致笛卡尔积 多个UNWIND会导致一个笛卡尔积的结果,这个结果可能会很大.例如下面的结果会得到3*3=9行,所以尽量避免笛卡尔积.
with [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;] as lts, [1,2,3] as nrs unwind lts as char unwind nrs as nr return char,nr 在MATCH中使用多个模式笛卡尔积 在MATCH中使用多个模式也会导致笛卡尔积,比较下面的2个结果相同的语句,第一个耗时80s,第二个只需8ms.
# 1. 笛卡尔积 80000 ms w/ ~900 players, ~40 teams, ~1200 games MATCH (pl:Player),(t:Team),(g:Game) RETURN COUNT(DISTINCT pl), COUNT(DISTINCT t), COUNT(DISTINCT g) # 2. 8ms w/~900 players, ~40 teams, ~1200 games MATCH (pl:Player) WITH COUNT(pl) as players MATCH (t:Team) WITH COUNT(t) as teams, players MATCH (g:Game) RETURN COUNT(g) as games, teams, players 模式中的方向 下面的查询中,如果给关系ACTED_IN添加上方向,可以提高查询速度.
MATCH (p:Person)-[:ACTED_IN]-(m) WHERE p.name = &amp;#34;Tom Hanks&amp;#34; RETURN m</content>
    </entry>
    
     <entry>
        <title>java generic</title>
        <url>https://xiongdahu.github.io/post/java-generic/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  泛型 // 类 class Tuple&amp;lt;T, S&amp;gt; { private T first; private S second; } // 泛型方法也可在非泛型类里面 class ArrayAlg { public static &amp;lt;T&amp;gt; T getMiddle(T... a) { return a[a.length / 2]; } }String middle = ArrayAlg.&amp;lt;String&amp;gt;getMiddle(&amp;#34;]ohnM, &amp;#34;Q.n, &amp;#34;Public&amp;#34;);// right,&amp;lt;String&amp;gt;可以省略  String middle = GenericCls.getMiddle(&amp;#34;hello&amp;#34;,0,null);// error  // Errr:(7, 45) java: 不兼容的类型: 推断类型不符合上限 // 推断: java.lang.Object&amp;amp;java.io.Serializable&amp;amp;java.lang.Comparable&amp;lt;? extends java.lang.Object&amp;amp;java.io.Serializable&amp;amp;java.lang.Comparable&amp;lt;?&amp;gt;&amp;gt; // 上限: java.lang.String,java.lang.Object  类型限定 public static &amp;lt;T extends Comparable&amp;gt; T min(T a) // 如果多个类型，则：T extends Comparable &amp;amp; Serializable // 只能有一个类，且类必须紧跟extends，但是可以有多个接口 类型擦除 //Tuple&amp;lt;T,S&amp;gt;在虚拟机变为 class Tuple { private Object first;//当调用getFirst时,则发生强制转换  private Object second; } //泛型方法同样有擦除 public static &amp;lt;T extends Comparable&amp;gt; T min(T a) // =&amp;gt; public static Comparable min(Comparable a) 约束  不能用基本类型实例化泛型,Pair&amp;lt;double&amp;gt;不允许
 运行时参数类型检查只能检查原始类型
 if (a instanceof Pair&amp;lt;String&amp;gt;) // Error if (a instanceof Pair&amp;lt;T&amp;gt;) // Error Pair&amp;lt;String&amp;gt; p = (Pair&amp;lt;String&amp;gt;) a; //warning 
 不能创建参数化类型的数组
 Pair&amp;lt;String&amp;gt;[] table = new Pair&amp;lt;String&amp;gt;[10]; // Error Pair&amp;lt;String&amp;gt;[] table; //声明是合法的,只是无法实例化 
 借助@SafeVarargs参数化类型的数组
java @SafeVarargs public static &amp;lt;T&amp;gt; void addAll(Collection&amp;lt;T&amp;gt; coll, T... ts) 
 Class类本身是泛型。 例如，String.daSS 是一个 Class 的实例（事实上，它是唯一的实例。) 因此，makePair 方法能够推断出 pair 的类型
 泛型类的静态上下文中类型变量无效
  public class Singleton&amp;lt;T&amp;gt; { private static T singlelnstance; // Error public static T getSinglelnstance{// Error if (singleinstance == null) {//construct new instance of T return singlelnstance; } } }  不能抛出或捕获泛型类的实例
  public class Problem&amp;lt;T&amp;gt; extends Exception { /* . . . */ } // Error can&amp;#39;t extend Throwable  泛型擦除的方法冲突
  public class Pair&amp;lt;T&amp;gt; { T first; T second; public boolean equals(T value) { //error 和Object.equals冲突  return first.equals(value) &amp;amp;&amp;amp; second, equals(value); } } 泛型继承 class Employee class Manager extends Employee //Pair&amp;lt;Employee&amp;gt; 和Pair&amp;lt;Manager&amp;gt; 没用任何继承关系 通配符 和 PECS Pair&amp;lt;? extends Employee〉 Pair&amp;lt;? super Manager 反射和泛型 </content>
    </entry>
    
     <entry>
        <title>IO-Java-Stream-Write-Reader</title>
        <url>https://xiongdahu.github.io/post/io-java-stream-write-reader/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  java reader writer stream 上次总结了java 678 中不同读写文件的方法，这次总结一下基本的IO流。网上的总结大部分是以Stream和Reader、Writer来介绍的。这次从封装层次来介绍。
首先是byte流，每次read()读取8 bits，并用一个int的低八位保存：
FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(&amp;#34;xanadu.txt&amp;#34;); out = new FileOutputStream(&amp;#34;outagain.txt&amp;#34;); int c; while ((c = in.read()) != -1) { out.write(c); } } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } byte流是很基础的流，接下来是字符流，使用int的低16位保存读取内容，一个汉字，使用上面那个字节流，需要读取2次，使用下面的字符流，只用一次。其实背后还是一个桥接
具体的对象体现：
FileReader extemds InputStreamReader,
FileWriter extends OutputStreamWriter
InputStreamReader:字节到字符的桥梁
OutputStreamWriter:字符到字节的桥梁：
FileReader inputStream = null; FileWriter outputStream = null; try { inputStream = new FileReader(&amp;#34;xanadu.txt&amp;#34;); outputStream = new FileWriter(&amp;#34;characteroutput.txt&amp;#34;); int c; while ((c = inputStream.read()) != -1) { outputStream.write(c); } } finally { if (inputStream != null) { inputStream.close(); } if (outputStream != null) { outputStream.close(); } } ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。StringBufferInputStream 已经被Deprecated，设计错误，只是为了兼容。
File I/O现在已经不推荐使用了，推荐nio2的Path及其工具类Files,Paths;
Path 官方教程
ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）
注意：OutputStream子类中没有StringBuffer为目的地的。ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。
几个特殊的类：
PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。
PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.err 就是PrintStream 的实例！ System.in是inputStream的实例！
你永远不应该new PrintStream,请用PrintWriter
看看字符流的对比：
CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。
BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。
FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。
InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。
OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。
PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。但是还是有不同的，PrintStream prints to an OutputStream, and PrintWriter prints to a Writer.
你永远不应该new PrintStream,请用PrintWriter
PrintStream stream = new PrintStream(outputStream); //With the PrintWriter you can however pass an OutputStreamWriter with a specific encoding. PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputStream, &amp;#34;UTF-8&amp;#34;)); Piped流 这是线程之间通信使用的。后面介绍。
RandomAccessFile类 该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：
该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。
该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)
注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。
Scanning and formatting The scanner API breaks input into individual tokens associated with bits of data,The formatting API assembles data into nicely formatted, human-readable form.
formatting
int i = 2; double r = Math.sqrt(i); System.out.format(&amp;#34;The square root of %d is %f.%n&amp;#34;, i, r);Scanner s = new Scanner(new BufferedReader(new FileReader(&amp;#34;xanadu.txt&amp;#34;))); By default, a scanner uses white space to separate tokens. also,u can set :
s.useDelimiter(&amp;quot;,\\s*&amp;quot;);
I/O from commandline You might expect the Standard Streams to be character streams, but, for historical reasons, they are byte streams. System.out and System.err are defined as PrintStream objects. Although it is technically a byte stream, PrintStream utilizes an internal character stream object to emulate many of the features of character streams.
By contrast, System.in is a byte stream with no character stream features. To use Standard Input as a character stream, wrap System.in in InputStreamReader.
InputStreamReader cin = new InputStreamReader(System.in);
！！！！妈的，老子开始就困惑很久了，一直不明白System.out怎么可以直接打印出中文。
jdk1.5开始读写控制台以前常用的是Scanner：
Scanner scanner = new Scanner(System.in); scanner.nextLine();  从 JDK1.6开始，基本类库中增加了java.io.Console 类，用于获得与当前 Java 虚拟机关联的基于字符的控制台设备。在纯字符的控制台界面下，可以更加方便地读取数据。
Console console = System.console(); if (console == null) { throw new IllegalStateException(&amp;#34;不能使用控制台&amp;#34;); } return console.readLine(prompt);  Data Streams Data streams support binary I/O of primitive data type values (boolean, char, byte, short, int, long, float, and double) as well as String values. All data streams implement either the DataInput interface or the DataOutput interface. This section focuses on the most widely-used implementations of these interfaces, DataInputStream and DataOutputStream.
致谢：Oubo的博客
</content>
    </entry>
    
     <entry>
        <title>Java-6-7-8-文件读写</title>
        <url>https://xiongdahu.github.io/post/io-java-6-7-8-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html"> 资料：Reading and writing text files
不要用File对象，改用Path对象，该对象既表示文件路径，也表示文件文本（应该认为文件也是路径的一部分），对于以前的File,可以File.toPath()得到一个Path对象。
Files是一个静态类，操作文件内容。Paths是静态工具类，操作文件路径，例如拼接文件路径，以前要使用平台无关的分隔符表示：File.pathSeparator， File.separator
现在可以直接使用下面方法
Path path = Paths.get(&amp;quot;~/test/&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;a.txt&amp;quot;);
下面一段代码很好的显示了在java678中的读取文件方法：
package angus.java.interview; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths; public class FileToStringJava678 { public static void main(String[] args) throws IOException { // How to read file into String before Java 7 	InputStream is = new FileInputStream(&amp;#34;filetoStringjava678.txt&amp;#34;); BufferedReader buf = new BufferedReader(new InputStreamReader(is)); String line = buf.readLine(); StringBuilder sb = new StringBuilder(); while (line != null) { sb.append(line).append(&amp;#34;\n&amp;#34;); line = buf.readLine(); } String fileAsString = sb.toString(); System.out.println(&amp;#34;Contents (before Java 7) : &amp;#34; &#43; fileAsString); // Reading file into Stirng in one line in JDK 7 	String contents = new String(Files.readAllBytes(Paths.get(&amp;#34;filetoStringjava678.txt&amp;#34;))); System.out.println(&amp;#34;Contents (Java 7) : &amp;#34; &#43; contents); // Reading file into String using proper character encoding 	String fileString = new String(Files.readAllBytes(Paths.get(&amp;#34;filetoStringjava678.txt&amp;#34;)), StandardCharsets.UTF_8); System.out.println(&amp;#34;Contents (Java 7 with character encoding ) : &amp;#34; &#43; fileString); // It&amp;#39;s even easier in Java 8 	Files.lines(Paths.get(&amp;#34;filetoStringjava678.txt&amp;#34;), StandardCharsets.UTF_8).forEach(System.out::println); } } 下面是更新版本，几乎所有文件操作都有了
// 记住，bytes 到string 永远指定字符集，即使目前只是英文文件。 // ### java 8按行读取：  public class Main { public static void main(String[] args) { String fileName = &amp;#34;c://lines.txt&amp;#34;; try (Stream&amp;lt;String&amp;gt; stream = Files.lines(Paths.get(fileName))) { stream.forEach(System.out::println);//or other thing you do with stream  } catch (IOException e) { e.printStackTrace(); } } } // ### java 7：  BufferedReader br = new BufferedReader(new FileReader(file)); String line; while((line = br.readLine()) != null) { // do something with line.  } // 输入流保存到文件： Files.copy(inputStream,filepath,StandardCopyOption.REPLACE_EXISTING); public class Java7IO { public static void main(String[] args) throws IOException { //读取所有字节：  Path path = Paths.get(&amp;#34;alice.txt&amp;#34;); String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8); System.out.println(&amp;#34;Characters: &amp;#34; &#43; content.length()); //读取所有行：  List&amp;lt;String&amp;gt; lines = Files.readAllLines(path, StandardCharsets.UTF_8); System.out.println(&amp;#34;Lines: &amp;#34; &#43; lines.size()); //JAVA 8 延迟处理：  try (Stream&amp;lt;String&amp;gt; lineStream = Files.lines(path, StandardCharsets.UTF_8)) { System.out.println(&amp;#34;Average line length: &amp;#34; &#43; lineStream.mapToInt(String::length).average().orElse(0)); } //按单词读取：  try (Scanner in = new Scanner(path, &amp;#34;UTF-8&amp;#34;)) { in.useDelimiter(&amp;#34;\\PL&#43;&amp;#34;);//？  int words = 0; while (in.hasNext()) { in.next(); words&#43;&#43;; } System.out.println(&amp;#34;Words: &amp;#34; &#43; words); } //读取一个网页：  URL url = new URL(&amp;#34;http://horstmann.com/index.html&amp;#34;); try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()))) { Stream&amp;lt;String&amp;gt; lineStream = reader.lines();////!!!! BufferedReader TO Stream  System.out.println(&amp;#34;Average line length: &amp;#34; &#43; lineStream.mapToInt(String::length).average().orElse(0)); } //PrintWriter 向文本写文件：  path = Paths.get(&amp;#34;hello.txt&amp;#34;); try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(path, StandardCharsets.UTF_8))) { out.println(&amp;#34;Hello&amp;#34;); } //Files.write向文本写文件：  content = &amp;#34;World\n&amp;#34;; Files.write(path, content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND); //多行写入  String fileName = &amp;#34;file.txt&amp;#34;; Path path = Paths.get(&amp;#34;file1.txt&amp;#34;); List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); try (Stream&amp;lt;String&amp;gt; lines = Files.lines(Paths.get(fileName))) { lines.forEach(list::add); Files.write(path, list, StandardCharsets.UTF_8); } catch (IOException e) { e.printStackTrace(); } //打印错误栈：  StringWriter writer = new StringWriter(); Throwable throwable = new IllegalStateException(); throwable.printStackTrace(new PrintWriter(writer)); String stackTrace = writer.toString(); System.out.println(&amp;#34;Stack trace: &amp;#34; &#43; stackTrace); } } // 直接将url中的pdf保存下来：//适用于任何二进制文件：URL url = new URL(&amp;#34;http://www.cninfo.com.cn/1202417936.PDF&amp;#34;); try (InputStream in = new BufferedInputStream(url.openStream())) { Files.copy(in, Paths.get(url.getFile().substring(1)),StandardCopyOption.REPLACE_EXISTING); }//url.getFile().substring(1)去掉起始地斜杠符 //copy()有三种形式 	//还有一种方式jdk7之前： URL website = new URL(&amp;#34;XXX.pdf&amp;#34;); ReadableByteChannel rbc = Channels.newChannel(website.openStream()); FileOutputStream fos = new FileOutputStream(url.getFile().substring(1)); fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE); //FileChannel的抽象方法abstract long	transferFrom(ReadableByteChannel src, long position, long count) </content>
    </entry>
    
     <entry>
        <title>Java-==-and-equal</title>
        <url>https://xiongdahu.github.io/post/java-and-equal/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html"> /** * samples for == and equal() * @author hsiung * */ class TestObj { // the class for test == and equal() } public class EqualAndCompare { public static void main(String[] args) { TestObj obj1 = new TestObj(); TestObj obj2 = new TestObj(); TestObj obj3 = obj1; System.out.println(obj1 == obj2);// false , 	// == Compares references, not values 	System.out.println(obj1 == obj3);// true  System.out.println(obj1.equals(obj2));// false, 	// equal() method is derived from java.lang.Object, if not override,nor 	// in superclass,then equal behave as same as == 	// Always remember to override hashCode if you override equals so as not 	// to &amp;#34;break the contract&amp;#34;. 	// As per the API, the result returned from the hashCode() method for 	// two objects must be the same if their equals methods shows that they 	// are equivalent. The converse is not necessarily true.  String s1 = &amp;#34;haha&amp;#34;;// constant pool 	String s2 = new String(&amp;#34;haha&amp;#34;);// defined in ?heap 	System.out.println(s1 == s2);// false ,== Compares references, not 	// values, there is a exception for 	// static field in class, static String 	// in class == and equal both always 	// return *true* 	// for more infomation，see : 	// http://stackoverflow.com/questions/7520432/what-is-the-difference-between-vs-equals-in-java  System.out.println(s1.equals(s2)); // true compare the 	// value  String s3 = s2.intern();// find the same value String in constant pool 	System.out.println(s1 == s3);// true  int i1 = 2;// primitive type has no equal() method 	Integer i3 = Integer.valueOf(2); System.out.println(i1 == i3);// true, i3 automatic unboxing into int; 	System.out.println(i3.equals(i1));// auto boxing into Integer  Integer i2 = 2; System.out.println(i3.compareTo(i2)); } /* * Comparable interface, a.compareTo(b) return -1：less,0:equal,1:greater. 0 * should always be returned for objects when the .equals() comparisons * return true. All Java classes that have a natural ordering implement this * (String, Double, BigInteger, ...). * * * Comparator interface: is a util for compare two instance,then you can use * the comparator to sort array and other things * */ }</content>
    </entry>
    
     <entry>
        <title>Java-AOP-sample</title>
        <url>https://xiongdahu.github.io/post/java-aop-sample/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html"> 找到一个最简单的介绍，不怎么想翻译，直接看原文吧:
A Simple Introduction to AOP
提醒个点，使用注解的方式写切面时，增加了一个空方法，即：
@Pointcut(&amp;#34;execution(* org.bk.inventory.service.*.*(..))&amp;#34;) public void serviceMethods(){ } 在使用xml配置的话，就不需要这个方法了，serviceMethods方法名是后面配置切点的引用。
如果不想引入spring的话，可以直接使用aspectj或者jboss aop。
</content>
    </entry>
    
     <entry>
        <title>Java-concurrency-1-概要</title>
        <url>https://xiongdahu.github.io/post/java-concurrency-1-%E6%A6%82%E8%A6%81/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  知识点太多了。先列举一些知识点，然后在分别做一点笔记。
模式 1。 共享可变性
2。 隔离可变性
3。 纯粹不可变性:STM,
IO密集型任务和计算密集型任务 读写文件和网络请求这种算IO密集型任务，阻塞时间长，任务阻塞系数接近1；线程池大一点好，
判断质数的这种任务属于计算密集型任务，阻塞系数约为0。
poolSize = cores/(1-blockingCofficient); cores 是处理器核心数。
场景：
根据网络服务api计算给定股票代码和股票数的资产总值。-IO密集
判断n以内的所有素数。 &amp;ndash; 计算密集
Java5以前的一些同步方法api 尽量不要使用，但是要理解。wait/notify、join等函数，synchronized volatile关键字的理解。笔记
 用ExecutorService代替Thread及其方法。笔记
 用Lock和子类的方法代替synchronized。但是不绝对。 笔记
 以前用wait/notify的地方，现在可以用CyclicBaerrier和CountDownLatch同步工具代替。笔记
  同步容器和并发容器 同步容器包括Vector和Hashtable(java.util.Properties 也是一个HashTable)，使用synchronized同步。不建议使用，但是要知道HashTable和HashMap区别：
Java 中 HashMap 和 HashTable 有几个不同点：
 Hashtable 是同步的，然而 HashMap 不是。 这使得HashMap更适合非多线程应用，因为非同步对象通常执行效率优于同步对象。
 Hashtable 不允许 null 值和键。HashMap允许有一个 null 键和一个 NULL 值。
 HashMap的一个子类是LinkedHashMap。所以，如果想预知迭代顺序（默认的插入顺序），只需将HashMap转换成一个LinkedHashMap。用Hashtable就不会这么简单。
 如果同步对你来说不是个问题，我推荐使用HashMap。如果同步成为问题，你可能还要看看ConcurrentHashMap。
  迭代hashmap最佳方式：
Iterator it = mp.entrySet().iterator(); while (it.hasNext()) { Map.Entry pair = (Map.Entry)it.next(); System.out.println(pair.getKey() &#43; &amp;#34; = &amp;#34; &#43; pair.getValue()); it.remove(); // avoids a ConcurrentModificationException } 并发容器是和java.util.concurrent包一块发布的。包括很多新的并发容器：
并发容器架构图
图中最底部的都是jdk1.5增加的并发容器：主要有：ConcurrentHashMap,CopyOnWriteList, BlockingQueue等。
参考书籍： Doug Lea 《Concurrent Programming in Java》 2004
Brian Goetz 《java concurrency in practice》 2007
Venkat 《Programming concurrency on the JVM》
</content>
    </entry>
    
     <entry>
        <title>Java-concurrency-2-Runnable-Callable-Future-Executor</title>
        <url>https://xiongdahu.github.io/post/java-concurrency-2-runnable-callable-future-executor/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  定义任务的内容 多线程编程的核心元素就是任务，任务是独立的活动。不依赖其他任务的状态，结果，以及边界效应。
定义任务的内容使用Runnable和Callable。
Runnable 接口表示没有返回的一个过程（procedure），没有受检异常。
Callabe 接口的call方法会返回一个结果，并有可能抛出受检异常。如果要表示没有返回值，可以使用Callable&amp;lt;Void&amp;gt;,但是不鼓励使用这个代替Runable，但一个任务内容没有返回值，只是利用副作用时，应该优先使用Runable，使得含义清晰，并且JDK中ScheduledExecutorService也有只能接收Runable的方法。
可以将Runnable定义的任务提交给Thread直接运行，但是这个线程是不可重用的。更好的方法是提交给执行器ExecutorService。
Future接口描述了任务的生命周期，并提供方法获得任务执行的结果。该接口有一个实现类：FutureTask。该类的实例一定和一个具体任务相关。ExecutorService所有的submit方法都会返回一个Future实例。你也可以直接通过FutureTask构造函数将Runnable/Callable构建一个FutureTask实例。该实例将管理该任务的生命周期
注意，FutureTask 实现了Runnable和Future（通过实现RunnableFuture 接口，如下），所以既可以使用ExecutorService，也可以使用Thread执行任务内容。
public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; Future.get是一个阻塞方法，如果任务没有结束或者没有抛出异常，那么会一直等待下去，如果需要异步的使用ComletionService。
ExecutorService 执行器框架，root 接口是Executor，只有一个execute方法执行runnable实例。更常用是子接口ExecutorService，除了可以执行runnable，callable，还可以invoke一callable集合：
&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;	invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) &amp;lt;T&amp;gt; T	invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt;	submit(Callable&amp;lt;T&amp;gt; task) Future&amp;lt;?&amp;gt;	submit(Runnable task) ScheduledExecutorService The ScheduledExecutorService interface supplements the methods of its parent ExecutorService with schedule, which executes a Runnable or Callable task after a specified delay. In addition, the interface defines scheduleAtFixedRate and scheduleWithFixedDelay, which executes specified tasks repeatedly, at defined intervals.
scheduleAtFixedRate: 第一次是initialDelay 后执行，第二次是initialDelay &#43; 1 * period 后执行，类推。
scheduleWithFixedDelay: 是前面任务执行结束后开始计算间隔计时。
两个方法都不会并发执行任务，特别是第一个方法，如果任务时间比参数中等待时间period长，那么只会延期执行。对于第二个方法，本来就是要等前面结束才执行，所以没有这个问题。两个方法遇到异常，那么后面任务也不会执行，因为任务是重复的，后面也会遇到异常。周期任务可以取消，或者遇到执行器终结才结束。
CompletionService 如果有多个任务，那么ExecutorService只能不停的轮询Future看是否有任务结束，并取得结果。CompletionService则是另外是自动的告诉你那些任务结果已经准备好。注意构造方法需要一个ExecutorService
 ExecutorService = incoming queue &#43; worker threads
CompletionService = incoming queue &#43; worker threads &#43; output queue 参考
ExecutorService executor = Executors.newFixedThreadPool(numberOfThreadsInThePool); CompletionService&amp;lt;String&amp;gt; completionService = new ExecutorCompletionService&amp;lt;String&amp;gt;(executor); for (final String num: nums) { completionService.submit(new Task(num)); //Task is Callable  } try { for (int t = 0, n = nums.size(); t &amp;lt; n; t&#43;&#43;) { Future&amp;lt;String&amp;gt; f = completionService.take(); System.out.print(f.get()); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (ExecutionException e) { Thread.currentThread().interrupt(); } finally { if (executor != null) { executor.shutdownNow(); } }</content>
    </entry>
    
     <entry>
        <title>Java-concurrency-3-synchronized-or-Lock</title>
        <url>https://xiongdahu.github.io/post/java-concurrency-3-synchronized-or-lock/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  synchronized method和synchronized block的区别 如果是synchronized(this),那么和synchronized 方法没有任何区别，锁定对象都是方法所在的对象。
synchronized void mymethod() { ... } void mymethod() { synchronized (this) { ... } } 但是synchronized block可以锁定其他对象，而且synchronized block的范围是可以控制更灵活，synchronized 方法的边界只能是整个方法
private void method() { ... code here ... code here ... code here synchronized( lock ) { ... very few lines of code here } ... code here ... code here ... code here ... code here } 不要忘记synchronized 这个指令是JVM内置的，也是未来可以优化的。如果只是简单的同步一个资源对象，就使用synchronized，而且，使用Lock有就必须出现一堆的try/finally。
使用ReentrantLock场景：
需要以下高级特性时 ： 可定时的，可轮询的，可中断的锁，公平队列，非块结构。
stackoverflow回答
</content>
    </entry>
    
     <entry>
        <title>Java-concurrency-4-CAS-and-atomic</title>
        <url>https://xiongdahu.github.io/post/java-concurrency-4-cas-and-atomic/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  AtomicLong code: public final long incrementAndGet() { for (;;) { long current = get(); long next = current &#43; 1; if (compareAndSet(current, next)) return next; } } //in java 8: public final long incrementAndGet() { return unsafe.getAndAddLong(this, valueOffset, 1L) &#43; 1L; } 基础 第一个版本是基于cas的，cas基于一个基础：有三个值，新值N，预期内存中的值E，内存中需要更新的值V，如果V == E,那么将V设置为N,返回V，结束；如果V != E，说明有别的线程动了这个v,那么不做修改直接返回V。cas在X86下对应的是 CMPXCHG 汇编指令
java8中则使用了x86的优化指令atomic fetch-and-add ，上面的代码直接等价于cpu的一条指令atomic fetch-and-add .性能更好
而compareAndSet利用JNI来完成CPU指令的操作。
public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } 注意 java.util.concurrent.atomic中的原子类使用了很多cas，但是这个方法一个是自己实现和使用需要很仔细，另一个在真的高并发中可能陷入死循环，因为方法中本身就是一个死循环：for (;;).java8为此提供了LongAdder.
关于垃圾自动回收的语言不会出现cas中aba问题的原理：stackoverflow
</content>
    </entry>
    
     <entry>
        <title>Java-concurrency-5-Synchronizer-and-AQS</title>
        <url>https://xiongdahu.github.io/post/java-concurrency-5-synchronizer-and-aqs/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  好难，看不懂呀！ 先自己写一个CountDownLatch的示例： CountDownLatch是管理一组线程和一个主线程的先后。主线程wait后就阻塞，直到所有的CountDownLatch调用countDown后主线程接着开始。
package angus.intrview.concurrent; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; public class CountDownLatchTest { // 这个方法将启动多个任务，并让它们同时执行，计算完成的时间 	public long timer(int taskNums) throws InterruptedException { CountDownLatch startLatch = new CountDownLatch(1); CountDownLatch finishLatch = new CountDownLatch(taskNums); for (int i = 0; i &amp;lt; taskNums; i&#43;&#43;) { Task task = new Task(startLatch, finishLatch, i); new Thread(task).start(); } long start = System.nanoTime(); startLatch.countDown();// 准备好线程后开始同时启动所有任务 	finishLatch.await();// 等待任务完成 	long end = System.nanoTime(); return end - start; } public static void main(String[] args) throws InterruptedException { CountDownLatchTest ct = new CountDownLatchTest(); long time = ct.timer(100); System.out.println(TimeUnit.NANOSECONDS.toSeconds(time) &#43; &amp;#34; SENCODS&amp;#34;); } } class Task implements Runnable { CountDownLatch startLatch; CountDownLatch finishLatch; int time; Task(CountDownLatch startLatch, CountDownLatch finishLatch, int time) { this.startLatch = startLatch; this.finishLatch = finishLatch; this.time = time; } @Override public void run() { try { startLatch.await();// 等待主线程通知任务开始 	System.out.println(&amp;#34;doing the task!&amp;#34;); Thread.sleep(time * 100); // 模拟任务过程 	} catch (InterruptedException e1) { // TODO Auto-generated catch block 	e1.printStackTrace(); } finally { System.out.println(&amp;#34;task done&amp;#34;); finishLatch.countDown();// 告诉主线程任务完成 	} } } CyclicBarrier // pass</content>
    </entry>
    
     <entry>
        <title>Java-动态代理</title>
        <url>https://xiongdahu.github.io/post/java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  好文 Java 动态代理机制分析及扩展
更深入的一篇:
java设计模式-动态代理模式
优势 相比 静态代理，动态代理具有更强的 灵活性，因为它不用在我们设计实现的时候就指定 某一个代理类来代理哪一个被代理对象，我们可以把这种指定延迟到程序运行时由 JVM来实现。
实例 动态代理类接口，接口规范方法。
package angus.interview.proxy; public interface Subject { public void request(); } 需要被代理的真实的类:
package angus.interview.proxy; public class SubjectImpl implements Subject { @Override public void request() { System.out.println(&amp;#34; subject request&amp;#34;); } } 先创建一个代理类。然后利用反射创建一个用真实类加载器创建的一个对象。该对象调用request方法实际上调用的是代理类的invoke方法。
package angus.interview.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class DynamicProxy implements InvocationHandler { private Object target; public Object bind(Object target) { this.target = target; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); // 要绑定接口this(这是一个缺陷，cglib弥补了这一缺陷) 	} @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&amp;#34;------------------before------------------&amp;#34;); Object result = method.invoke(target, args); System.out.println(&amp;#34;-------------------after------------------&amp;#34;); return result; } } static void main(){ DynamicProxy proxy = new DynamicProxy(); Subject subject= proxy.bind(SubjectImpl); subject.request(); } 和静态代理模式比较的好处
在静态代理模式时,一个真实角色必须对应一个代理角色,如果大量使用会导致类的急剧膨胀;而动态代理则不会有这个问题，我们将接口中的方法委托给invoke方法，并在invoke中实现拦截。
源码分析 参考:http://rejoy.iteye.com/blog/1627405 主要原来:生成了一个代理类的class文件。 Proxy.newProInstance()方法
public static Object newProxyInstance(ClassLoader loader,Class&amp;lt;?&amp;gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException { if (h == null) { throw new NullPointerException(); } final Class&amp;lt;?&amp;gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkProxyAccess(Reflection.getCallerClass(), loader, intfs); } // 这里是生成class的地方  Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs); // 使用我们实现的InvocationHandler作为参数调用构造方法来获得代理类的实例  try { final Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (sm != null &amp;amp;&amp;amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) { return AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() { public Object run() { return newInstance(cons, ih); } }); } else { return newInstance(cons, ih); } } catch (NoSuchMethodException e) { throw new InternalError(e.toString()); } }  其中newInstance只是调用Constructor.newInstance来构造相应的代理类实例，这里重点是看getProxyClass0这个方法的实现:
private static Class&amp;lt;?&amp;gt; getProxyClass0(ClassLoader loader, Class&amp;lt;?&amp;gt;... interfaces) { // 代理的接口数量不能超过65535，这是class文件格式决定的  if (interfaces.length &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;interface limit exceeded&amp;#34;); } // JDK对代理进行了缓存，如果已经存在相应的代理类，则直接返回，否则才会通过ProxyClassFactory来创建代理  return proxyClassCache.get(loader, interfaces); } 其中代理缓存是使用WeakCache实现的，如下
private static final WeakCache&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt; proxyClassCache = new WeakCache&amp;lt;&amp;gt;(new KeyFactory(), new ProxyClassFactory()); 具体的缓存逻辑这里暂不关心，只需要关心ProxyClassFactory是如何生成代理类的，ProxyClassFactory是Proxy的一个静态内部类，实现了WeakCache的内部接口BiFunction的apply方法:
private static final class ProxyClassFactory implements BiFunction&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt; { // 所有代理类名字的前缀  private static final String proxyClassNamePrefix = &amp;#34;$Proxy&amp;#34;; // 用于生成代理类名字的计数器  private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces) { // 省略验证代理接口的代码……  String proxyPkg = null; // 生成的代理类的包名  // 对于非公共接口，代理类的包名与接口的相同  for (Class&amp;lt;?&amp;gt; intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { String name = intf.getName(); int n = name.lastIndexOf(&amp;#39;.&amp;#39;); String pkg = ((n == -1) ? &amp;#34;&amp;#34; : name.substring(0, n &#43; 1)); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( &amp;#34;non-public interfaces from different packages&amp;#34;); } } } // 对于公共接口的包名，默认为com.sun.proxy[源码](http://hg.openjdk.java.net/jdk6/jdk6/jdk/rev/695dd7ceb9e3)  if (proxyPkg == null) { proxyPkg = ReflectUtil.PROXY_PACKAGE &#43; &amp;#34;.&amp;#34;; } // 获取计数  long num = nextUniqueNumber.getAndIncrement(); // 默认情况下，代理类的完全限定名为:com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1……依次递增  String proxyName = proxyPkg &#43; proxyClassNamePrefix &#43; num; // 这里才是真正的生成代理类的字节码的地方  byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces); try { // 根据二进制字节码返回相应的Class实例  return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } catch (ClassFormatError e) { throw new IllegalArgumentException(e.toString()); } } } ProxyGenerator是sun.misc包中的类，它没有开源，但是可以反编译来一探究竟:
public static byte[] generateProxyClass(final String var0, Class[] var1) { ProxyGenerator var2 = new ProxyGenerator(var0, var1); final byte[] var3 = var2.generateClassFile(); // 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘，  //我们可以通过把相应的class文件保存到本地，再反编译来看看具体的实现，这样更直观  if(saveGeneratedFiles) { AccessController.doPrivileged(new PrivilegedAction() { public Void run() { try { FileOutputStream var1 = new FileOutputStream(ProxyGenerator.dotToSlash(var0) &#43; &amp;#34;.class&amp;#34;); var1.write(var3); var1.close(); return null; } catch (IOException var2) { throw new InternalError(&amp;#34;I/O exception saving generated file: &amp;#34; &#43; var2); } } }); } return var3; } saveGeneratedFiles这个属性的值从哪里来呢:
private static final boolean saveGeneratedFiles = ((Boolean)AccessController.doPrivileged( new GetBooleanAction(&amp;#34;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;#34;))).booleanValue(); GetBooleanAction实际上是调用Boolean.getBoolean(propName)来获得的，而Boolean.getBoolean(propName)调用了System.getProperty(name)，所以我们可以设置sun.misc.ProxyGenerator.saveGeneratedFiles这个系统属性为true来把生成的class保存到本地文件来查看。
反编译class文件
自己创建文件写入生成的动态代理类:
package angus.interview.proxy; import java.io.FileOutputStream; import java.io.IOException; import sun.misc.ProxyGenerator; @SuppressWarnings(&amp;#34;restriction&amp;#34;) public class ProxyGeneratorUtils { public static void writeProxyClassToHardDisk(String path) { // 获取代理类的字节码 	byte[] classFile = ProxyGenerator.generateProxyClass(&amp;#34;$Proxy11&amp;#34;, SubjectImpl.class.getInterfaces()); FileOutputStream out = null; try { out = new FileOutputStream(path); out.write(classFile); out.flush(); } catch (Exception e) { e.printStackTrace(); } finally { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } } 测试我们的工具类:
package angus.interview.proxy; public class TestProxy { public static void main(String[] args) { System.getProperties().put(&amp;#34;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;#34;, &amp;#34;true&amp;#34;); DynamicProxy proxy = new DynamicProxy(); Subject sproxy = (Subject) proxy.bind(new SubjectImpl()); sproxy.request(); ProxyGeneratorUtils.writeProxyClassToHardDisk(&amp;#34;$Proxy11.class&amp;#34;); } } 刷新目录，得到一个$Proxy11.class,反编译使用Java Decompiler，GUI傻瓜式，支持最新语法，编译慢，效果好:
可以看到
$Proxy11继承Proxy，并实现了Subject，同时我们写的那个InvocationHandler的子类DynamicProxy也被传递进去了。
重点看request方法的代码，只有一行 this.h.invoke(this, m3, null);其中h的引用就是DynamicProxy.
m3就是m3 = Class.forName(&amp;quot;angus.interview.proxy.Subject&amp;quot;).getMethod(&amp;quot;request&amp;quot;, new Class[0]);
import angus.interview.proxy.Subject; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy11 extends Proxy implements Subject { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy11(InvocationHandler paramInvocationHandler) { super(paramInvocationHandler); } public final boolean equals(Object paramObject) { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final String toString() { try { return (String)this.h.invoke(this, m2, null); } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final void request() { try { this.h.invoke(this, m3, null); return; } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final int hashCode() { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (Error|RuntimeException localError) { throw localError; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } static { try { m1 = Class.forName(&amp;#34;java.lang.Object&amp;#34;).getMethod(&amp;#34;equals&amp;#34;, new Class[] { Class.forName(&amp;#34;java.lang.Object&amp;#34;) }); m2 = Class.forName(&amp;#34;java.lang.Object&amp;#34;).getMethod(&amp;#34;toString&amp;#34;, new Class[0]); m3 = Class.forName(&amp;#34;angus.interview.proxy.Subject&amp;#34;).getMethod(&amp;#34;request&amp;#34;, new Class[0]); m0 = Class.forName(&amp;#34;java.lang.Object&amp;#34;).getMethod(&amp;#34;hashCode&amp;#34;, new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } }</content>
    </entry>
    
     <entry>
        <title>Java-注解和注解处理器sample</title>
        <url>https://xiongdahu.github.io/post/java-%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8sample/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  注解处理 注解是jdk1.5出现的,但是自定义处理注解的功能是1.6才有的.Element等关于注解源码抽象的支持类都是1.6出现的.
关于注解的定义就不说了,主要说说注解处理
本文根据以下资料并进行部分修改：
JavaAnnotationProcessing
基本知识 annotation processing integrated into javac compiler
– since Java 6.0; known as pluggable annotation processing
– compiler automatically searches for annotation processors
– unless disabled with -proc:noneoption for javac
– processors can be specified explicitly with -processor option for javac or -cp processor.jar,processor.jar include /META-INF/service/javax.annotation.processing.Processor file and your processor decalared in file;
implement a processor class
– must implement Processor interface
– typically derived from AbstractProcessor
– new package javax.annotation.processing
同时自定义注解处理器需要指定注解选项： specify supported annotation &#43; options
– by means of annotations:
@SupportedAnnotationTypes
@SupportedOptions
@SupportedSourceVersion
编译器编译源码是会有很多轮(round)：
1st round：编译器得到所有的注解-获取所有的注解处理器-进行match并process,如果匹配的处理器中process方法的返回值是true,表示该注解被 claim,不再查询其他处理器.如果是false,接着查询匹配处理器处理,所以注解处理器在META-INF/services/javax.annotation.processing.Processor声明顺序是有关系的&amp;ndash; 所有的注解都被claim后,注解处理完成.
如果注解处理器产生新的java文件,那么新的一轮处理开始,前面被调用的那些处理器又被调用,直到没有java文件产生.
最后一轮又要调用一遍所有处理器,完成他们的各自工作.
最最后,编译器编译源码和注解处理器生成的源码.
还有一个很重要的类AbstractProcessor： 有一个引用processingEnv
提供了两个重要工具类：
– Filer for creation of new source, class, or auxiliary files
– Messager to report errors, warnings, and other notices
此外，一个产生java文件的重要方法：
FileObject sourceFile = processingEnv.getFiler().createSourceFile(beanClassName); process() method takes 2 arguments: Set&amp;lt;? extends TypeElement&amp;gt; annotations – the annotation types requested to be processed – subset of the supported annotations RoundEnvironment roundenv – environment for information about the current and prior round – supplies elements annotated with a given annotation or all root elements in the source  一个自定义的注解处理器格式如下：
@SupportedAnnotationTypes({&amp;#34;Property&amp;#34;}) @SupportedSourceVersion(SourceVersion.RELEASE_6) public class PropertyAnnotationProcessor extends AbstractProcessor { public boolean process(Set&amp;lt;? extends TypeElement&amp;gt; annotations, RoundEnvironment env) { process the source file elements using the mirror API } } jdk1.6 对注解的处理支持建立在对源码的抽象,Element是javax.lang.model.*中定义的,各种Element是对源码抽象数据结构,如：
package com.example;	// PackageElement public class Foo {	// TypeElement  private int a; // VariableElement  private Foo other; // VariableElement  public Foo () {} // ExecuteableElement  } TypeElement不能提供父类的信息,如果需要这些信息,需要从Element中得到TypeMirror.TypeMirror::element.asType()
实例： 动手写注解处理器：3个类,一个定义注解Comparator.java,一个使用注解的类Name.java,一个处理注解MyProcessor.java.
我将定义一个注解@Comparator,使用在方法上,被注释的方法能够返回一个Comparator.
一个注解处理器,解析所有被注释的方法,为每一个方法产生一个Comparator类.
！！！注意,这里的内容和连接中资料的已经不一样了,资料里给的process方法并不能产生比较器类.
给出注解定义前看看注解怎么使用：
// ./Name.java ./表示当前命令行文件夹,后面所有的javc命令都以这个文件夹为准 package java.interview.annotation; public class Name { private final String first; private final String last; public Name(String f, String l) { first = f; last = l; } @Comparator(&amp;#34;NameByFirstNameComparator&amp;#34;) public int compareToByFirstName(Name other) { if (this == other) return 0; int result; if ((result = this.first.compareTo(other.first)) != 0) return result; return this.last.compareTo(other.last); } } 其中被注解注释的方法将产生一个NameByFirstNameComparator.java文件：
// ./angus/initerview/annotation/NameByFirstNameComparator.java public class NameByFirstNameComparator implements java.util.Comparator&amp;lt;Name&amp;gt; { public int compare(Name o1, Name o2) { return o1.compareToByFirstName(o2); } public boolean equals(Object other) { return this.getClass() == other.getClass(); } } 我们定义注解：
// ./Comparator.java package angus.interview.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Comparator { String value(); } 接下来定义我们的注解处理器,有详细注解,特别注意generate源码中的空格和分号不要弄丢了：
package angus.interview.annotation; import java.io.IOException; import java.io.PrintWriter; import java.util.Set; import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.Element; import javax.lang.model.element.ExecutableElement; import javax.lang.model.element.TypeElement; import javax.lang.model.type.PrimitiveType; import javax.lang.model.type.TypeKind; import javax.lang.model.type.TypeMirror; import javax.tools.Diagnostic; import javax.tools.FileObject; @SupportedAnnotationTypes({ &amp;#34;angus.interview.annotation.Comparator&amp;#34; }) @SupportedSourceVersion(SourceVersion.RELEASE_8) public class MyProcessor extends AbstractProcessor { @Override public boolean process(Set&amp;lt;? extends TypeElement&amp;gt; annotations, RoundEnvironment roundEnv) { for( final Element element: roundEnv.getElementsAnnotatedWith( Comparator.class ) ) { if(element instanceof ExecutableElement){ ExecutableElement m = (ExecutableElement) element; TypeElement className = (TypeElement)m.getEnclosingElement(); Comparator a = m.getAnnotation(Comparator.class); if (a != null) { TypeMirror returnType = m.getReturnType(); if (!(returnType instanceof PrimitiveType) || ((PrimitiveType) returnType).getKind() != TypeKind.INT) { processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, &amp;#34;@Comparator can only be applied to methods that return int&amp;#34;); continue; } // prepare for java file generation 	// t m a mean ? 	String comparatorClassName = a.value(); String comparetoMethodName = m.getSimpleName().toString(); String theProcessedClassesName = className.getQualifiedName().toString(); try { writeComparatorFile(theProcessedClassesName, comparatorClassName, comparetoMethodName); } catch (IOException e) { e.printStackTrace(); } } } } return true;// claimed now,no need next processor 	} /* * * public class NameByFirstNameComparator implements java.util.Comparator&amp;lt;Name&amp;gt; { * public int compare(Name o1, Nameo2) { return o1.compareToByFirstName(o2); } * * public boolean equals(Object other) { return this.getClass() == other.getClass(); } } */ //!!!careful with spaces and &amp;#34;;&amp;#34;!!! 	private void writeComparatorFile(String fullClassName, String comparatorClassName, String compareToMethodName) throws IOException { int i = fullClassName.lastIndexOf(&amp;#34;.&amp;#34;); String packageName = fullClassName.substring(0, i); FileObject sourceFile = processingEnv.getFiler().createSourceFile(packageName &#43; &amp;#34;.&amp;#34; &#43; comparatorClassName); if (sourceFile == null) { System.out.println(&amp;#34;create source file failed&amp;#34;); } PrintWriter out = new PrintWriter(sourceFile.openWriter()); if (i &amp;gt; 0) { out.println(&amp;#34;package &amp;#34; &#43; packageName &#43; &amp;#34;;&amp;#34;); } String parametrizedType = fullClassName.substring(i &#43; 1);//!! 	out.println( &amp;#34;public class &amp;#34; &#43; comparatorClassName &#43; &amp;#34; implements java.util.Comparator&amp;lt;&amp;#34; &#43; parametrizedType &#43; &amp;#34;&amp;gt; {&amp;#34;); out.println(); out.println(&amp;#34;public int compare( &amp;#34; &#43; parametrizedType &#43; &amp;#34; o1 , &amp;#34; &#43; parametrizedType &#43; &amp;#34; o2 ){&amp;#34;); out.println(&amp;#34;return o1.&amp;#34; &#43; compareToMethodName &#43; &amp;#34;(o2);&amp;#34;); out.println(&amp;#34;}&amp;#34;); out.println(); out.println(); out.println(&amp;#34;public boolean equals(Object other) {&amp;#34;); out.println(&amp;#34;return this.getClass() == other.getClass();&amp;#34;); out.println(&amp;#34;}&amp;#34;); out.println(&amp;#34;}&amp;#34;); out.close(); } } 测试处理器 两种方法,
一种是使用 -cp：
在项目的根目录中（pom.xml同级目录）新建META-INF文件夹,并在里面新建services文件夹,再在里面新建一个文件 javax.annotation.processing.Processor,并在该文件中注册我们的处理器,第一行写入：angus.interview.annotation.MyProcessor.
然后用eclipse将项目export得到一个jar包,jar必须包含target文件夹（处理器class文件）和META-INF文件夹（注册处理器）.这里将jar包命名为process.jar. 复制jar包到Name.java目录中,并在该目录打开终端,输入：
 javac -cp process.jar Name.java
 将会得到Name.class文件和一个angus文件夹,最里面是NameByFirstNameComparator.java和NameByFirstNameComparator.class.
打开NameByFirstNameComparator.java,发现内容和上面给出的一模一样.
第二种方法是使用-processor参数,但是还没搞懂MyProcessor.class应该放在哪里.暂时先到这.
</content>
    </entry>
    
     <entry>
        <title>gradle笔记1-理解build脚本基本语法</title>
        <url>https://xiongdahu.github.io/post/gradle-%E7%90%86%E8%A7%A3build%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  在看这个之前，希望你已经用ant或者maven的使用经验，还有，对groovy的语法有一个简单的了解，不懂也没关系，下面会介绍。理解gradle文件的前提是理解一个重要的groovy概念:closure
closure 一个closure是一个定义在groovy文件中的{}代码块，这个代码块类似js中的匿名函数，它可以被赋值给变量，可以被调用，可以接收参数，还可以作为参数传递给别的函数。
closure中最重要的两个概念是委托对象和作为参数传递的语法格式（理解gradle文件很重要）。
groovy方法调用括号的省略 groovy提供非常优雅的方法调用格式，总结起来是:
//可以省略参数括号，并且链式调用 // equivalent to: turn(left).then(right) turn left then right //groovy数字可以直接转换成字符串 // equivalent to: take(2.pills).of(chloroquinine).after(6.hours) take 2.pills of chloroquinine after 6.hours //两个参数用逗号隔开 // equivalent to: paint(wall).with(red, green).and(yellow) paint wall with red, green and yellow //命名参数用分号 // with named parameters too // equivalent to: check(that: margarita).tastes(good) check that: margarita tastes good //闭包作为参数也可以省略括号 // with closures as parameters // equivalent to: given({}).when({}).then({}) given { } when { } then { } //没有参数的方法必须有括号 // equivalent to: select(all).unique().from(names) select all unique() from names //如果调用链元素为奇数，那么最后一个元素是前面方法链返回对象的属性 //cookies 是take(3)返回值的一个属性 // equivalent to: take(3).cookies // and also this: take(3).getCookies() take 3 cookies 上面调用的格式是dsl的基础。也是看懂gradle文件格式的基础。
让我们再深入一点，上面讲的是调用格式，那么怎么创建这种可以链式调用的方法呢？
 groovy和scala的方法返回值不需要return，最后一行就是返回值。
 closure是一个匿名函数，格式{ [closureParameters -&amp;gt; ] statements }，默认自带一个名为it的参数，所以只接受一个参数时可以省略-&amp;gt;。
 closure可以访问scope（作用域）内任何变量。并且这个scope是可以通过委托来改变的。
 groovy中Map对象的value如果是closure，那么可以接着调用:mapp.keyy({closure})
有了上面的基础，我们看一个简单的例子:
  //将closure赋值给一个变量，这个closure接收一个参数，参数名是默认的，it show = { println it } square_root = { Math.sqrt(it) } //为了容易理解，我将参数的type都添加上了， //please方法需要一个closure，接着返回一个map，map的key是the，value是一个closure， //这个closure接收一个closure，并返回一个map，这个map的of的value又是一个closure(不要晕了) //最后一个closure接收一个参数n。 def please(Closure action) { [the: { Closure what -&amp;gt; [of: { n -&amp;gt; action(what(n)) }] }] } //调用: // 等价: please(show).the(square_root).of(100) please show the square_root of 100 // ==&amp;gt; 10.0 总结一下就是，将你需要的操作封装成一个closure，给一个直观的命名，保证整个DSL调用语句有语义，定义返回一个map的函数作为入口，map的key是方法名，value是closure，这样可以在key后面传递一个closure接着调用这个value。
委托对象 gradle脚本是一个配置脚本，类似maven中pom.xml文件，不过gradle脚本更为强大，因为.gradle文件就是grrovy文件，所以还可以在脚本里面直接定义groovy对象让脚本使用。
委托对象就是一个groovy对象，用来执行gradle构建脚本中的closure。
as a build script executes, it configures an object of type Project. This object is called the delegate object of the script. The following table shows the delegate for each type of Gradle script. 三种不同的gradle脚本对应的委托对象 Build script（build.gradle） -&amp;gt;Project Init script	-&amp;gt;Gradle Settings script(setting.gradle)	-&amp;gt;Settings 构建中的每一个project，Gradle都会创建一个Project对象，并将这个对象与构建脚本相关联。
Project对象与build.gradle是一对一的关系。
Gradle的脚本是配置脚本，当脚本执行时，它是在配置某一个特殊类型的对象。比如一个构建脚本的执行，它就是在配置一个Project类型的对象。这个对象叫做脚本的代理对象。
委托有个重要的概念就是scope，指closure的变量引用范围:有时变量不在当前scope中，但是可以通过委托，改变closure的委托对象，这样就拥有了委托者的scope，从而可以在closure中使用委托者的变量。
关于groovy closure 的委托有三个重要属性
• this: refers to the instance of the class that the closure was defined in. • owner: is the same as this, unless the closure was defined inside another closure in which case the owner refers to the outer closure. • delegate: is the same as owner. But, it is the only one that can be programmatically changed, and it is the one that makes Groovy closures really powerful. the closure itself will be checked first, followed by the closure&amp;#39;s this scope, than the closure&amp;#39;s owner, then its delegate. However, Groovy is so flexible this strategy can be changed. Every closure has a property called resolvedStrategy. This can be set to: • Closure.OWNER_FIRST • Closure.DELEGATE_FIRST • Closure.OWNER_ONLY • Closure.DELEGATE_ONLY 来自 &amp;lt;https://dzone.com/articles/groovy-closures-owner-delegate&amp;gt;  gradle是dsl解析工具，是对groovy语法的扩展，build.gradle可以理解为就是一个.groovy文件，gradle会解析这个文件，发现里面的closure，并将这些closure委托给一个对象去执行。
gradle将groovy的委托机制发挥到极致，要理解gradle内部，就要理解closure的委托！！
closure作为参数传递 将closure作为参数传递的方法有多种:
//method accepts 1 parameter - closure myMethod(myClosure) //if method accepts only 1 parameter - parentheses can be omitted myMethod myClosure //I can create in-line closure myMethod {println &amp;#39;Hello World&amp;#39;} //method accepts 2 parameters myMethod(arg1, myClosure) //or the same as &amp;#39;4&amp;#39;, but closure is in-line myMethod(arg1, { println &amp;#39;Hello World&amp;#39; }) //if last parameter is closure - it can be moved out of parentheses myMethod(arg1) { println &amp;#39;Hello World&amp;#39; } 注意第三种和最后一种调用方式，是不是和gradle文件中很眼熟？只不过在gradle脚本中出现的closure更加复杂，因为有closure嵌套！！！但是万变不离其宗。下面我们会介绍嵌套不过是委托链的表现。
看一个脚本代码:
buildscript { repositories { jcenter() } dependencies { classpath &amp;#39;com.android.tools.build:gradle:1.2.3&amp;#39; } } buildscript是一个方法，接收一个closure。至于这个方法在哪，可以定义在任何地方，但是可以肯定的是，这个方法一定能够被Project对象调用。
因为build.gradle脚本就是委托给Project对象执行的。事实上，Project对象也不是亲自执行这个方法，而是委托给ScriptHandler执行。
这里，我们ScriptHandler对象会搜索到两个配置closure:repositories和dependencies。我们可以在ScriptHandler api中搜索到这两个方法。从api中我们又发现:
传递给dependencies的closure又被委托给了DependencyHandler对象&amp;hellip;&amp;hellip;. 这就是委托链。
ScriptHandler api
Project api
注意:这里buildscript {&amp;hellip;}整体称为一个 script block。 脚本块就是一个接受closure参数的方法调用。还有的方法是不接受closure的，那些称为statement（看下面解释）。
 A script block is a method call which takes a closure as a parameter
 插件 先看看构建脚本的构成:
 A build script is made up of zero or more statements and script blocks. Statements can include method calls, property assignments, and local variable definitions. A script block is a method call which takes a closure as a parameter. The closure is treated as a configuration closure which configures some delegate object as it executes.
 就是说脚本有两种内容:script block和statement.
Project接口预先定义了几个block:
allprojects { }	Configures this project and each of its sub-projects. artifacts { }	Configures the published artifacts for this project. buildscript { }	Configures the build script classpath for this project. configurations { }	Configures the dependency configurations for this project. dependencies { }	Configures the dependencies for this project. repositories { }	Configures the repositories for this project. sourceSets { }	Configures the source sets of this project. subprojects { }	Configures the sub-projects of this project. publishing { }	Configures the PublishingExtension added by the publishing plugin. 这些closure参数基本都是委托给其他对象执行的。
可以看到，Project对象的方法是有限而且通用的。真正有用的是插件，gradle的很多功能也是通过官方写的插件提供的。
如果你看到一个顶级层的something { ... }block，但是在Project源码中没有找到something block的任何信息。那么这个方法就是通过插件提供的。gradle自带很多插件,像java，eclipse,groovy，android等。
看一个实际的例子:
在andoird开发中的构建脚本:
apply plugin: &amp;#39;com.android.application&amp;#39; android { compileSdkVersion 22 buildToolsVersion &amp;#34;22.0.1&amp;#34; defaultConfig { applicationId &amp;#34;com.trickyandroid.testapp&amp;#34; minSdkVersion 16 targetSdkVersion 22 versionCode 1 versionName &amp;#34;1.0&amp;#34; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&amp;#39;proguard-android.txt&amp;#39;), &amp;#39;proguard-rules.pro&amp;#39; } } } 这里，出现了android{},Project对象并没有这个script block。所以，这其实是由插件提供的block。我们找到com.android.application入口代码
extension = project.extensions.create(&amp;#39;android&amp;#39;, AppExtension, this, (ProjectInternal) project, instantiator, buildTypeContainer, productFlavorContainer, signingConfigContainer) setDefaultConfig(extension.defaultConfig, extension.sourceSetsContainer) extensions是一个ExtensionContainer实例，其中create API:
&amp;lt;T&amp;gt; T create(String name, Class&amp;lt;T&amp;gt; type, Object... constructionArguments)
这里就创建了一个android属性，是一个AppExtension对象，我们在脚本中提供给android block的{}其实是配置了一个AppExtension对象。我们可以在AppExtension中找到compileSdkVersion等属性。
所以，插件扩展的Project对象，提供了很多方法，这样，可以在脚本中使用插件定义的方法（script block）了。
一个插件就是实现实现了org.gradle.api.Plugin接口的groovy类。
我们看怎么写一个插件:
//build.gradle apply plugin: GreetingPlugin //这里提供closure 来配置插件提供的greeting script block greeting { message = &amp;#39;Hi&amp;#39; greeter = &amp;#39;Gradle&amp;#39; } class GreetingPlugin implements Plugin&amp;lt;Project&amp;gt; { void apply(Project project) {//注意我们是如果扩展Project对象的，通过extensions对象创建一个script block:greeting,而这个block关联的是一个对象  project.extensions.create(&amp;#34;greeting&amp;#34;, GreetingPluginExtension) project.task(&amp;#39;hello&amp;#39;) &amp;lt;&amp;lt; { //注意我们是如何使用greeting的，没有通过extensioins  println &amp;#34;${project.greeting.message} from ${project.greeting.greeter}&amp;#34; } } } class GreetingPluginExtension { String message String greeter } /* project.task(&amp;#39;hello&amp;#39;) &amp;lt;&amp;lt; { println &amp;#34;${project.greeting.message} from ${project.greeting.greeter}&amp;#34; } 使用了重载操作符，等价: project.task(&amp;#39;hello&amp;#39;).leftShift({ println &amp;#34;${project.greeting.message} from ${project.greeting.greeter}&amp;#34; }) */ 官方文档:如何自己写一个插件
参考: gradle-tip-2
Gradle深入与实战（六）Gradle的背后是什么？
DSL语法 gradle使用的基于groovy中的DSL语法，所谓的dsl，就是基于groovy发明的新的“编程语言”，gradle dsl是groovy的超集，就是你可以完全使用groovy的语法，但是你还是会看到很多不是groovy语法，这时不要困惑，这些语法不过是gradle利用groovy提供的元编程能力提供的新语法。
以新建task的语法为例，在Project API中有四个重载形式:
Task task(String name, Closure configureClosure); Task task(Map&amp;lt;String, ?&amp;gt; args, String name, Closure configureClosure); Task task(Map&amp;lt;String, ?&amp;gt; args, String name) throws InvalidUserDataException; Task task(String name) throws InvalidUserDataException; 但是你会看到这样的调用方式:
task intro(dependsOn: hello) { doLast { println &amp;#34;I&amp;#39;m Gradle&amp;#34; } } 这是dsl，具体的解析方式在TaskDefinitionScriptTransformer
具体见我在sf的提问gradle task method syntax in build.gradle
more tips gradle-tips
</content>
    </entry>
    
     <entry>
        <title>单例模式和序列化</title>
        <url>https://xiongdahu.github.io/post/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html">  参考资料
饱汉式 public class Singleton { private static Singleton instance = null private Singleton (){} public static Singleton getInstance() { if(instance == null)instance = new Singleton();return instance; } } //饱汉式，使用时创建 饿汉式 //加载时创建对象 static public class Singleton { private Singleton instance = null; static { instance = new Singleton(); } private Singleton (){} public static Singleton getInstance() { return this.instance; } } ```	### 静态内部类 public class Singleton {
private Singleton (){} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static final Singleton getInstance() { return SingletonHolder.INSTANCE; }  }
//这个比较好，线程安全，也达到了延迟加载效果。
### 枚举类 //这个是最好的这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊
public enum Singleton { INSTANCE; public void whateverMethod() { }  }
访问这个单例 Singleton.INSTANCE
### 双重校验锁 其实是不安全的，多线程开销很大，甚至死锁。原因在于指令重排序。public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }  }
### 序列化 使用静态内部类举例，只要提供一个readResolve方法：```	public class Singleton { private Singleton (){} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } private Object readResolve() throws ObjectStreamException{return SingletonHolder.INSTANCE; } } 无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象，而被创建的对象则会被垃圾回收掉。
</content>
    </entry>
    
     <entry>
        <title>面试题-类加载过程和子类重写父类方法的调用</title>
        <url>https://xiongdahu.github.io/post/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</url>
        <categories>
          <category>编程</category>
        </categories>
        <tags>
          <tag>java</tag><tag>code</tag>
        </tags>
        <content type="html"> 最近一道非常火的携程面试题:
public class Base { private String baseName = &amp;#34;base&amp;#34;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub extends Base { private String baseName = &amp;#34;sub&amp;#34;; public void callName() { System.out.println(baseName) ; } } public static void main(String[] args) { Base b = new Sub();//输出？  } } 我的理解：
先理解两个方法:
class 的(clinit)方法和(init)方法不同：这两个方法一个是虚拟机在装载一个类初始化的时候调用的（&amp;lt;clinit&amp;gt;）。另一个是在类实例化时调用的（&amp;lt;init&amp;gt;）。
在加载类时需要类的初始化，JVM对应的字节码方法是&amp;lt;clinit&amp;gt;，这个方法会初始化static变量和执行static{}代码块，按源码定义的顺序执行。注意：如果static{}代码块中引用了static 变量，那么一定要使用之前定义static变量。ide会提示的。
这时，class的其他成员变量和方法都没有被执行。变量的内存都已经分配，值为null或者0（基本类型），false(布尔类型)。
当创建一个类的实例时，此时会调用&amp;lt;init&amp;gt;方法,这个方法会初始化非static变量和执行{}代码块。注意，这两个也是按源码顺序执行的。所以代码块如果要使用非static变量，一定要先定义。同样ide一般会提示的。但是要明白这个顺序。
以上说的执行顺序通过eclipse调试可以确定是正确的。
所以组合起来 创建一个类的实例对象需要下面的顺序：
父类P static代码块和static变量初始化 -&amp;gt; 子类S static代码块和static变量初始化 -&amp;gt; 父类P 非static代码块和非static变量初始化 -&amp;gt;父类P构造函数 -&amp;gt; 子类S非static代码块和非static变量初始化 -&amp;gt; 子类S构造函数
回到面试题：我们看看创建一个实例对象的调用栈：
可以看到依次进入16， 8， 21行代码:
16行：static class Sub extends Base
8行：callName();//Base()构造函数中
21行：System.out.println (baseName) ;//Sub的callName()
根据前面的分析，这个类没有static代码块和static变量，也没有代码块。所以第一个执行的是父类非静态成员的base=&amp;laquo;base&amp;raquo;;接着执行构造函数Base();这里到了魔法的一步，调用的callName()是子类（21行）的方法。这个行为就是 动态单分派。详细资料看最后。由于子类的非static变量初始化没有完成，所有子类中的base变量是null。输出也是null。
！！！所以，不要再构造函数中调用可能会被子类覆盖的方法。
有的面试题会出现陷阱:在调用callName()方法改为this.callName(). 其实都是一样的。在调用Base构造函数时没有Base的实例对象，调用者其实还是Base$Sub这个类。
还有一个进阶版：
public class Basic { public void add(int i) { System.out.println(&amp;#34;Basic add&amp;#34;); } public Basic() { add(&amp;#39;a&amp;#39;); } public static void main(String[] args) { Basic a = new A(); B b = new B(); } } class A extends Basic { public void add(int i) { System.out.println(&amp;#34;A add&amp;#34;); } } class B extends Basic { public void add(char i) { System.out.println(&amp;#34;B add&amp;#34;); } } 不仅考察单分派，还有重载的静态多分派。
进阶版问题的解释需要一下知识点：
java的静态分派和动态单分派资料：
CSDN-类加载机制-深入java虚拟机 读书笔记
方法分派
重载是静态多分派，编译时期确定。
覆盖是动态单分派，运行时通过实际类型绑定。
静态多分派:
静态分派 意思是 所有依赖静态类型来定位方法执行版本的分派过程就叫做静态分派，静态分派最典型的应用就是方法重载。
动态单分派:
动态单分派 意思是 根据运行期实际类型确定方法执行版本的分派过程叫做动态分派，动态分派最典型的应用就是方法重写。
同时理解，动态单分派就是多态，java的面向接口编程的根基就是多态。
</content>
    </entry>
    
     <entry>
        <title>Posts</title>
        <url>https://xiongdahu.github.io/post/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
</search>